

# 网络&浏览器

### http和https的区别

- http时客户端与服务器请求和应答的标准（TCP），用于从WWW服务器**传输超文本**到本地浏览器的协议
  - 默认端口是 80

- https是在http协议上添加了**SSL**层进行加密
  - 默认端口是 443
  - 比http费时，会使页面加载时间延长50%

---



### TCP三次握手

> 总是要问：为什么需要三次握手，两次不行吗？
>
> ​	其实这是由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。
>
> >第一次握手可以确认客服端的**发送能力**，
> >
> >第二次握手，确认了服务端的**发送能力和接收能力**
> >
> >第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象。

- **第一次握手：**`建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认`；SYN：同步序列编号（Synchronize Sequence Numbers）。
- **第二次握手：**`服务器收到syn包并确认客户的SYN`（ack=j+1），`同时也发送一个自己的SYN包`（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- **第三次握手：**`客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）`，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手

> 三次握手完毕后，服务端和客户端才开始进行数据传递



#### 三次握手中可以携带数据吗？

> 其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**
>
> 为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。
>
> 也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。**



#### SYN攻击是什么？

> **服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。
>
> SYN攻击就是Client在短时间内**伪造大量不存在的IP地址**，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪





### TCP四次挥手



### [HTTP请求跨域问题](https://juejin.cn/post/7194734127390654520?searchId=202311302133351F9CFA318A5384090E13#heading-7)

1. **什么是跨域**

   > **跨域**是一种浏览器的**安全机制**
   >
   > 是由于浏览器的**同源策略引**起的，`同源策略是浏览器最核心的安全功能，没有他浏览器容易遭受到XSS,CSRF攻击`
   >
   > 同源协议指**协议（http）+ 域名 + 端口号**组成，只要其中一项不同都被视作跨域请求

2. 如何处理跨域

   > - **jq的ajax自带解决跨域的方法**。底层原理采用的JSONP的跨域解决方案。如下
   >
   >   - ``` js
   >     function callback(){
   >         console.log("月薪一千五，心比美式苦")
   >     }
   >                 
   >     $.ajax({
   >         url: 'http://www.domain2.com:8080/login',
   >         type: 'get',
   >         dataType: 'jsonp',  // 请求方式为jsonp  设置跨域的重点
   >         jsonpCallback: "callBack",  // 回调函数
   >     });
   >     ```
   >
   > - **前端代理跨域**
   >
   > - **服务端代理（Nginx）**
   >
   > - **后端添加响应头解决**

---



### 内网穿透、公网IP



### 浏览器的缓存机制（强制缓存&&协商缓存）

`浏览器会根据服务器返回的响应报文中HTTP头的缓存标识，决定是否缓存结果`

- 强制缓存

  > `强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。`当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 `Expires` 和 `Cache-Control`，其中Cache-Control优先级比Expires高。
  >
  > 强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：
  >
  > 1. 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。
  > 2. 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。
  > 3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

- 协商缓存

  > `协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程`，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：`Last-Modified / If-Modified-Since` 和 `Etag / If-None-Match`，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：
  >
  > 1. 协商缓存生效，返回304
  > 2. 协商缓存失效，返回200和请求结果结果



### 进程、线程、协程

**进程**是一个具有一定**独立功能的程序**在一个数据集上的一次动态执行的过程，`是操作系统进行资源分配和调度的一个独立单位`，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。

**线程**是程序执行中一个单一的顺序控制流程，是`程序执行流的最小单元`，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

**协程**，英文Coroutines，是一种`基于线程之上，但又比线程更加轻量级的存在`，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

---



# HTML

#### HTML5新特性有哪些、什么是语义化

1. 新特性

- > - **语义化标签： **HTML5引⼊了很多新的标签，如<header>、 <footer>、 <nav>、 <article>、 <section>等，这些标签都是为了更好地表达⽂档内容的语义⽽设计的。
  > - **多媒体⽀持：** HTML5 ⽀持多媒体内容，包括⾳频、视频、 SVG 和 Canvas 等**图形元素**，这些都可以直接在⽹
  >   ⻚中嵌⼊，⽆需使⽤第三⽅插件。
  > - **新的表单控件：** HTML5 引⼊了⼀些新的表单控件，如⽇期选择器、搜索框、滑块等，这些控件都能够提⾼⽤
  >   户体验。
  > - **Web 存储：** HTML5 提供了两种新的客户端存储机制： **localStorage 和 sessionStorage**，它们可以让 Web 应
  >   ⽤程序在客户端上存储数据，从⽽提⾼性能和⽤户体验。
  > - **Web Workers：** HTML5 提供了⼀种新的机制，即 Web Workers，它们可以让 Web 应⽤程序在后台运⾏，从
  >   ⽽提⾼性能和响应速度。
  > - **地理位置⽀持：** HTML5 提供了⼀种新的 API，即 Geolocation API，它可以让 Web应⽤程序获取⽤户的地理
  >   位置信息。  

2. 语义化

- > **语义化**是指通过**具有含义的标签**来表示页面内容的**结构和意义**
  >使得页面具有良好的结构，这样无论是谁都能看懂这块内容是什么；
  
- > **为什么要有语义化：**
  >
  > 1. 能让人更加易懂代码（增加代码的可读性）
  > 2. 更加便于维护和修改
  > 3. 可以让搜索引擎以及爬虫能够获取到更多的有效信息
  > 4. 可以在没有css的样式下也能有很好的解构

- **常见的语义化标签**

  ```txt
  <header></header>：用于定义页面的介绍展示区域，通常包括网站logo、主导航、全站链接以及搜索框
  
  <nav></nav>：定义页面的导航链接部分区域
  
  <main></main>：定义页面的主要内容，一个页面只能使用一次。
  
  <article></article>：定义页面独立的内容，它可以有自己的header、footer、sections等
  
  <section></section>：元素用于标记文档的各个部分，例如长表单文章的章节或主要部分
  
  <aside></aside>：一般用于侧边栏，表示与它周围文本没有密切关系的内容
  
  <footer></footer>：文档的底部信息
  ```





#### 什么是DOCTYPE!，有什么作用？

- DOCTYPE是HTML5的**文档声明标签**，主要是用它来**告诉浏览器应该用哪个版本的HTML标准来解析文档**。



#### html有哪些常用的标签

- **标题标签：**<h1>~<h6> 

- **段落标签：**<p> 
- **链接标签：**<a>
- **图像标签：**<img>
- **列表标签：**<ol>  <ul>  <li>
- **表格标签：**<table>  <tr>  <th>  <td>
- **表单标签：**<form>  <input>  <textarea>  <select>  <button>



#### script标签中的defer和async的区别？

1. **script**——	会**阻碍html标签的解析**，必须等下载并执行完脚本后才会继续解析html
2. **async**——    一边解析html，一边进行脚本的**异步下载**，但是在下载完后会立即执行，有可能会阻断html的解析
3. **defer**——     在html**解析完成后**再进行脚本的顺序**下载**







#### 前端页面由哪三层构成

- **构成：**`结构层（html）`，`表示层(css)`,`行为层(js)`
- **结构层：**
  - 结构层就是相当于人体骨架，他是由html超文本语言来创建的，也就是页面中的各种标签，也是用户能看到的所用内容；
- **表示层：**相当于人体皮肤，由css创建，可与定义html标签的样式；
- **行为层：**相当于人的肢体动作，由JavaScript语言创建，可以使网页的内容与用户产生交互，当用户操作的网页中的属性后，可以给用户一个反馈；





---

#### src 和 href 的区别

- 两者都可以用于**引入外部资源**

- **src**

  > 全称*source*，它通常用于img、video、audio、script元素，通过src指向请求外部资源的来源地址，**指向的内容会嵌入到文档中当前标签所在位置**，在请求src资源时，它会将资源下载并应用到文档内，比如说：js脚本、img图片、frame等元素。当**浏览器解析到该元素时，会暂停其它资源下载，直到将该资源加载、编译、执行完毕**。
  >
  > 这也是为什么将js脚本放在底部而不是头部的原因。

- **href**

  > 全称*hyper reference*，意味着**超链接**，**指向网络资源**，当浏览器识别到它指向的⽂件时，就会**并⾏下载资源**，不会停⽌对当前⽂档的处理，通常用于a、link元素。



#### img 上的 title 与 alt

- **alt : ** 如果浏览器无法显示图像，则将显示 alt 中的内容；
- **title：**当鼠标移动到图片上时显示的内容



---

#### 行内元素有哪些？块级元素有哪些？空（void）元素有哪些？

- > **行内元素与块级元素的区别：**
  >
  > 1. 块级元素独占一行，行内元素可以和其他行内元素共占一行
  >
  > 2. 块级元素可以设置高度宽度，行内元素宽高不可控
  >
  >    1. >**块级-->行内:**	display:inline
  >       >
  >       >**行内-->块级:**	display:block

- **行内元素：**`<a> <b> <span> <img> <input> <select> <strong>`

- **块级元素：**`<div> <table> <form> <ul> ol li dl dt dd h1~h6 p`

- **空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素 *没有闭合标签*：**
  - **常见的有：**`<br>`、`<hr>`、`<img>`、`<input>`、`<link>`、`<meta>`
  - **鲜见的有：**`<area>`、`<base>`、`<col>`、`<colgroup>`、`<command>`、`<embed>`、`<keygen>`、`<param>`、`<source>`、`<track>`、`<wbr>`。



#### HTML5中drag（拖拽）API的使用??????????

- `首先要把元素设置为可拖动 draggable="true"`

- **dragstart：**被拖放元素，在**开始**拖放被拖放元素时触发。
  - 

- **darg：**被拖放元素，在**正在**拖放被拖放元素时触发
  - 需要在拖拽的时候先禁止默认事件发生`e.preventDefault()`

- **dragenter：**目标元素，在被拖放元素**进入某元素**时触发。
- **dragover：**当被拖拽的物体进入放置区域时触发，在被拖放**在某元素内移动**时触发。
- **dragleave：**目标元素，在被拖放元素**移出**目标元素是触发。



- **drop：**元素**被放置后**触发的事件，在目标元素完全接受被拖放元素时触发。
- **dragend：**事件主体是被拖放元素，在整个拖放操作结束时触发。



#### label标签的作用

- label标签不会向用户呈现任何特殊效果，是用来定义表单控件的关系的，当选择label标签后，浏览器会自动聚焦到与label标签绑定的表单控件；



#### 前缀为  data-xxx   的元素属性的作用

- data-xxx   名字叫**自定义属性



#### 再浏览器地址栏输入url后会发生什么？

> url主要由“协议”，“主机”，“端口”，“路径”，“查询参数”，“锚点” 6部分组冲

1. **解析url**，解析出**“协议，主机，端口，路径**”等信息

2. **DNS域名解析:**

3. **TCP连接:**

   1. > 总是要问：为什么需要三次握手，两次不行吗？
      >
      > ​	其实这是由 TCP 的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的接收和发送能力**。
      >
      > 第一次握手可以确认客服端的**发送能力**，
      >
      > 第二次握手，确认了服务端的**发送能力和接收能力**
      >
      > 第三次握手才可以确认客户端的**接收能力**。不然容易出现丢包的现象。

4. **http请求**

5. **服务器处理请求并返回HTTP报文**

6. **浏览器接受数据并开始渲染界面**

7. **断开TCP连接**





#### sessionStorage，localStorage 和 cookie 的区别

1. 共同点：都是保存在浏览器端，且同源的

2. 区别:

   - > - cookie 始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；
     >
     >   而 sessionStorage 和 localStorage 不会自动把数据发送到服务器，仅在本地保存。
     >
     >   cookie 还有路径（path）的概念，可以限制 cookie 只属于某个路径下。
     >
     >   
     >
     > - 存储大小限制不同。cookie 不能超过 4K，因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如：会话标识。sessionStorage 和 localStorage 虽然也有存储大小限制，但比 cookie 大得多，可以达到 5M 或更大。
     >
     > - 数据有效期不同。sessionStorage 仅在当前浏览器窗口关闭之前有效；localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前有效。
     >
     > - 作用域不同。sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。



#### iframe 有哪些优缺点？

**优点：**

> 1. iframe 能原封不动的把嵌入的网页展现出来。
> 2. 如果有多个网页引用 iframe，只需修改 iframe 的内容，就可以实现调用每一个页面的更改，方便快捷。

**缺点：**

> 1. iframe 会阻塞主页面的 onload 事件。
> 2. iframe 和主页面共享链接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载。
> 3. 不利于 SEO，代码复杂，无法一下被搜索引擎索引到。
> 4. iframe 框架页面会增加服务器的 http 请求，对于大型网站不可取。
> 5. 很多移动设备无法完全显示框架，设备兼容性差。

注意：通过动态给 iframe 添加 src 属性值，可解决前两个问题。





# css

#### css常见50道面试题：https://segmentfault.com/a/1190000013325778

#### 盒模型

> CSS的盒模型是用于**布局和定位元素的概念**。它由内容区域、内边距、边框和外边距组成，这些部分依次包裹在元素周围。

> ***标准盒模型***：margin + border + padding + content
>
> ***IE盒模型：***margin  + content（border + padding ）

- 在HTML页面中的所有元素都可以看成一个盒子
- **盒子的组成部分：**外边距（margin）、边框（border）、内边距（padding）、内容（content）
- **控制盒模型的转换**
  - **box-sizing :** content-box（标准盒模型） /  	border-box（IE盒模型）



#### css布局定位方法

1. 普通流（默认）

    > - 元素按照先后顺序从上到下布局
    >
    > - 行类元素水平排列，直到当行被沾满

2. 浮动（float）

    > - 元素一开始是按照**普通流**进行排列
    > - 给某个元素设置浮动后，这个元素就会**脱离文档流**（就像把这个元素提到了另一个平面，原来平面的盒子就不会被撑开，只有使用bfc才能避免脱离文档流）

3. 绝对定位（position：absoluted）

    > - 元素会**脱离文档流**，所以会对父元素有影响**（子绝父相）**

- **BFC属于普通流**





---

#### BFC

- Block Formatting Context	**块级格式化上下文**				**（BFC属于普通流布局）**

- `BFC`可以看做是一个`CSS`元素属性，当元素具有这种属性后，就被看作一个完全独立的容器（布局环境），让空间里的子元素不会影响到外面的元素布局`即便bfc容器内的元素全部脱离文档流，也不会印象到外部元素的布局`

- **触发BFC**

  - > 这里简单列举几个触发`BFC`使用的`CSS`属性
    >
    > - overflow: hidden
    > - display: inline-block
    > - position: absolute
    > - position: fixed
    > - display: table-cell
    > - display: flex

- **BFC的作用**

  - > - 避免外边距重叠（因为这是两个独立的容器）
    > - 清除浮动带来的影响（子元素可以撑开父元素）
    > - 避免元素被浮动元素覆盖（给正常元素添加bfc）

#### 清除浮动

浮动会造成元素脱离文档流，导致父元素坍塌

- **清除浮动的方式**
  - 给父元素添加大小（height）
  - 在最后一个浮动元素后边加上一个空的<div>，并添加 **clear：both**样式
  - 给父元素添加BFC

```js
//在css中添加:after伪元素
.parent::after{
    /* 设置添加子元素的内容是空 */
    content: '';
    /* 设置添加子元素为块级元素 */
    display: block;
    /* 设置添加的子元素的高度0 */
    height: 0;
    /* 设置添加子元素看不见 */
    visibility: hidden;
    /* 设置clear：both */
    clear: both;
}
```



#### Flex布局

- 容器属性

  - > - **flex-direction**：决定主轴的方向
    >   - `flex-direction: row | row-reverse | column | column-reverse;`
    > - **justify-content**：主轴元素的排列方式
    >   - `justify-content:flex-start | flex-end | center | space-around | space-between`
    > - **flex-wrap**：设置子元素是否换行
    >   - `flex-wrap: nowrap | wrap;`
    > - **align-items**：侧轴元素的排列方式（单行）         
    >   - `align-items: flex-start | flex-end | center | stretch`
    > - **align-content**：侧轴元素的排列方式（多行）
    >   - `align-items: flex-start | flex-end | center | space-around | space-between | stretch`

- 子元素属性

  - > - order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0
    >
    > - flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大
    >
    > - flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小
    >
    > - flex-basis 属性：定义了在分配多余的空间，项目占据的空间。
    >
    > - flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。
    >
    > - align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖
    >
    > - align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局





#### 2、css选择器的优先级

> CSS选择器用于选择要应用样式的HTML元素

- **css的特征**：继承性、层叠性、优先级

- ***优先级的大小***

  - ```！important > 行内样式 > id > 类/伪类/属性  > 标签 > 全局选择器```

- **什么是优先级**：在编写css属性的时候，会给同一个对象添加多个样式，此时只有权重大的样式才会显示

- **css选择器种类**

  - 常见的选择器

    - 元素选择器 	`a,p,div,ul{xxxx:xxxx}`

    - 类选择器

    - id选择器

    - 属性选择器

      - ```html
        <a class="test" src='/test.html'>我会红</a>
        <style>
        [src^="test"]{
        	color:blue;
        }
        .test[src]{
        	color:red;
        }
        /*属性选择器通过[attr=*]来选择具有该属性的元素，属性值支持通配符(不做具体详解)形式，优先级较低，多种选择器可以结合使用，上例中，后者优先级高于前者，所以呈现的字体为红色。*
        </style>
        ```
  
  - **子元素和后代元素选择器**



#### 3、隐藏元素的方法有哪些

- display : none;			 
- opacity : 0;
- visibility : hidden;
- position : absolute;



####  4、px和rem的区别是什么

- px 是像素单位，是屏幕上的像素点，是一个**绝对单位**
- rem  是一个**相对单位**，它的大小是相对于 ***html根节点***的**font-size**的值



#### 5、重绘、重排有什么区别

>***浏览器的渲染机制：***
>
>> 1.浏览器解析html标记后生成DOM树
>>
>> 2.浏览器解析css标记后生成Cssom树
>>
>> 3.将DOM树与CSSOM树合并生成**渲染树**
>>
>> 4.浏览器根据生成的渲染树进行布局，也就是确定每个节点的位置及大小**（这里就叫重排，因为浏览器要去计算盒子模型的位置）**
>>
>> 5.浏览器对页面进行绘制

- **重排（回流）：**只要影响到了元素的大小和布局，引擎就会根据所有的样式，重新去计算出盒模型在页面中的位置和大小

- **重绘：**当盒子的大小和位置计算好后，浏览器会根据每个盒模型的其他样式进行绘制

```text
总结：
重排  =>  当我们对DOM的大小、位置进行更改后，浏览器需要重新计算元素的几何属性，这就是重排（回流）；
重绘  =>  当DOM的样式改变后，浏览器就要进行重绘（例如：color或者background改变后）
```



#### 6、 让一个元素水平垂直居中的方法有哪些？

1、定位+margin

2、定位+transform

3、f1ex布局

4、grid布局

5、table布局



#### 7、css的哪些属性可以继承，哪些不可以继承？

- **继承：**子元素可以从父元素中获取一些属性

**可以被继承的属性：**

- 1、字体的一些属性：front
- 2、文本的一些属性：
- 3、元素的可见性：visibility
- 4、表格布局的属性
- 5、列表属性：
- 6、页面样式属性
- 7、声音的样式属性



#### 8、有没有用过预处理器？（less，sass）

```text
由于css并没用什么逻辑可言，这就导致了后期维护的时候需要在很多css代码中寻找对应的css语句。
并且由于css是对单一盒子进行的设置，导致无法重复利用
```

**什么是预处理器：**

> css预处理器定义了一种新的语言。用一种专门的编程语言，为css增加了一些编程的特性，将css作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。

**预处理器的种类：**

- less
- sass



#### css的单位有哪些

- **相对单位：**相对于另一个元素的单位

  >- **字体相对单位：**em、rem、ex、ch
  >
  >  - em ————相对长度单位，
  >
  >    - > **如果自身元素是没有设置字体大小的，那么就会根据其父元素的字体大小作为参照去计算，如果元素本身已经设置了字体，那么就会基于自身的字体大小进行计算**
  >
  >- **视窗相对单位：**vm、vh
  >
  >  - **vw：**视窗宽度的百分比
  >  - **vh：**视窗高度的百分比；

- **绝对单位：**

  > 绝对单位是一个固定的值，它反应了一个真实的物理尺寸。它不会受屏幕大小或者字体的影响。它们的大小取决于值以及**屏幕的分辨率**（DPI，每英寸的点数）

  > - **px**    ————  表示**像素**，但是不严格等于显示器的像素
  > - **pt**     ————  表示**点**，常用于软件设计和排版印刷行业，当使用这个单位时，无论显示器的分辨率是多少，打印在纸上的结果都是一样的。
  > - **pc**     ————   表示**派卡**，`1pc = 16px`
  > - cm（厘米）、mm（毫米）、in（英寸）

- **角度单位**

  > - **换算关系：**  `90deg = 100grad = 0.25turn ≈ 1.570796326794897rad`
  > - **deg：**表示度，一个圆总共360度  `transform: rotate(2deg);`
  > - **grad：**表示梯度，一个圆总共400梯度。`transform: rotate(2grad);`
  > - **rad：**表示弧度，一个圆总共2π弧度。 `transform: rotate(2rad);`
  > - **turn：**表示圈（转），一个圆总共一圈（转）`transform:rotate(.5turn);`

---



#### dispaly : none 和 visibility：hidden 的区别

- dispaly: none ------- 不显示对应的元素，在布局中不会再分配空间（重排+重绘）
-  visibility：hidden------ 隐藏对饮元素，再布局中任然保留原来的空间（重绘）

---



#### 常见的css布局方式

- **盒模型布局：**通过margin，padding，border等属性来控制元素在页面中的位置；
- **浮动布局：**float，使元素脱离文档流，向左或向右浮动
- **定位布局：**通过设置元素position属性为relative、 absolute 或 fixed 来控制元素位置
- **弹性布局：**设置元素的 display 属性为 flex 或 inline-flex  
- **网格布局：**设置元素的 display 属性为 **grid **使⽤**⽹格线**将⻚⾯分为若⼲⾏和列，控制元素在
  ⻚⾯中的位置和⼤⼩  

---



#### 元素水平居中

- 行内元素 : `text-align: center`;

- 对于确定宽度的**块级元素**：

  （1）width和margin实现。`margin: 0 auto`;

  （2）绝对定位和margin-left: (父width - 子width）/2, 前提是父元素position: relative

- flex布局：`justify-content:center`



#### 元素垂直居中

- 纯文字：`line-height`设置文字与行高相同（字体图标也可以使用）
- flex布局：`align-items: center`



#### 隐藏页面中元素的方法

- `opacity：0`，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的
- `visibility：hidden`，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）
- `display：none`，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）
- vue
  - v-if
  - v-show



####  CSS优化、提高性能的方法有哪些？

1. 避免过度约束
2. 避免后代选择符
3. 避免链式选择符
4. 使用紧凑的语法
5. 避免不必要的命名空间
6. 避免不必要的重复
7. 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么
8. 避免！important，可以选择其他选择器
9. 尽可能的精简规则，你可以合并不同类里的重复规则



#### ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用

1. 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。
2. ::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。

:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after



### position的值

- **static（默认）：**按照正常文档流进行排列；
- **relative（相对定位）：**不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；
- **absolute(绝对定位)：**参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；
- **fixed(固定定位)：**所固定的参照对像是可视窗口



### 精灵图的用法

1. 先测量精灵图的大小

2. 将精灵图设置为div的背景（这才是精灵图的用法）

3. **精灵图定位**

   1. > 图片向左移动为负
      >
      > 图片向上移动为负
      >
      > `background : url(xxxxx)  no-repeat  left top`

> [注]：





# js

> **js特性：动态的，弱类型的，解释型的，单线程的，基于对象的脚本语言**

https://juejin.cn/post/7016593221815910408#heading-30

###js由哪三部分组成

- **ECMAScript：**JS的***核心内容***，描述了js语言的**基础语法**(标准化了脚本语言)，例如：var，for，数据类型（数组、字符串）

- **文档对象模型（DOM树）：**DOM把整个HTML页面规划为元素构成的文档

  - > 文档对象模型（DOM, Document Object Model） 是针对XML但经过扩展用于HTML的应用程序编程接口。
    >
    > DOM把整个页面映射为一个多层节点结构，每一个节点可视为一个对象，**这些对象依照层级关系形成一颗树，这颗树就命名为DOM树**。 有了对象，编程就方便多了，只要一层层拿到对象就可以优雅地改变对象的属性进而动态地改变HTML等文档的展示。

- **浏览器对象模型（BOM）：**对浏览器窗口进行访问和操作

  - >**每个浏览器窗口都是一个window对象**。
    >（前面我也说过万物皆对象，**每个浏览器窗口都是一个window对象，里面包含很多属性，自有属性和自定义属性**。在每打开一个浏览器时，就已经默认创建了一个window对象，注意每一个页面不共享window，每次创建的全局变量和函数都是属于window对象的属性和方法



### ES6的新特性（ES2015）

- **let 和 const 的变量声明**
  
  - >- 解决了var的变量的**声明提升**和**变量重复声明**的问题`（声明提升：变量在声明之前就被使用，那么这时变量的值为undefine，因为变量提升了）`
    >- **let** 和 **const **具有块级作用域（两个没有声明提升是因为存在暂时性死区）
    >
    >  - > **暂时性死区：**如果区块中存在 let 和 const 命令，这个区块对这些命令**声明**的变量，从一开始就形成了封闭作用域。
  
- **模板字符串：**

  - ```js
    const name = '小明';
    const score = 59;
    const result = `${name}${score > 60?'的考试成绩及格':'的考试成绩不及格'}`;
    
    【注】：在${}中可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。
    ```

- **解构赋值**

  - ```js
    const {a:别名,b,c,d,e} = obj || {};  // 其中obj为一个对象
    const f = a + d;
    const g = c + e;
    
    【注】：结构的对象不能为undefined或者null，所以默认要加上一个空对象上去
    ```

- **拓展运算符：**

  - ```js
    const a = [1,2,3];
    const b = [1,5,6];
    const c = [...new Set([...a,...b])];//[1,2,3,5,6]---set可以进行数组去重
    
    const obj1 = {
      a:1,
    }
    const obj2 = {
      b:1,
    }
    const obj = {...obj1,...obj2};//{a:1,b:1}
    ```

- **箭头函数**

- **Promise对象：**

  - 

- **set和map数据结构：**

  - 

- **for...of 循环**

- **异步函数**

  - ```js
    const fn = async () =>{
      const res1 = await fn1();
      const res2 = await fn2();
      console.log(res1);// 1
      console.log(res2);// 2
    }
    ```





### js数据类型有哪些？

- **基本数据类型**
  - Number
  - String
  - Boolean
  - undefined
  - null
  - **Symbol**（ES6新增）
  - **BigInt**（ES6新增）
- **引用数据类型**
  - Object
  - function
  - Array
  - Date
  - RegExp

> - **基本数据类型**的值都是存储咋**栈**中，占用的控件小、会被频繁的使用
> - **引用数据类型**存储在**堆**中，占据空间大



### js有哪些常用的内置对象

[js常用的内置对象](https://juejin.cn/post/6844904196244783117)

- [Array数组方法](https://juejin.cn/post/6844903614918459406?searchId=202311280934100882EB16547D222DD408#heading-6)
- Math数学计算方法
- String方法
- Date日期对象

---



### js操作数组的方法有哪些

[数组的方法详解](https://juejin.cn/post/6844903614918459406)

- **改变原数组**
  
  - push————向数组默认添加元素
  
  - pop————删除数组末尾元素
  
  - unshift————向数组头部添加元素
  
  - shift————删除数组头部元素
  
  - splice————**向/从数组中添加/删除**项目，然后返回被删除的项目
  
    - ```js
      删除元素-----新数组 = 原数组.splice(起始索引index, 需要删除的个数);
      
      增加元素-----新数组 = 原数组.splice(起始索引index, 需要删除的个数（这里写0就行了）, 新的元素1, 新的元素2...);
      ```
  
  - sort————数组排序
  
  - reverse————颠倒数组元素的顺序
  
  - ES6：copyWithin() ————将指定位置的成员复制到指定位置
  
  - ES6:   fill（）——————填充数据到指定位置
  
- **不改变原数组**
  
  - slice————从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。
    - `新数组 = 原数组.slice(开始位置的索引, 结束位置的索引); `
  - join————以指定**分隔符**将数组元素生成字符串
  - concat————合并两个或多个数组，返回一个新的字符串
  - indexOf————在数组中查找一个指定元素，并返回下标，不存在则返回-1
  - lastIndexOf————从后往前查找指定元素
  - includes————查找数组中是否包含指定元素，返回布尔值
  - toLOcaleString————将数组转换为字符串
  
- **遍历数组**
  
  - forEach————遍历数组
  - every————检测数组中**所有元素**是否符合给定的条件
  - some————判断数组中**是否存在**符合条件的元素
  - filter————过滤原数组，返回一个新数组
  - map————将所有元素调用函数后的结果，形成一个新的数组
  - reduce————累加器，将每个元素的结构累加起来，最终输出一个值
  - find————找出第一个符合条件的元素，并返回该元素，没有找到则返回-1
  - findIndex————返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1

---



### set和map

- **set**

  > - 是一个构造函数，用来存储任意**数据类型**的**唯一值**；
  > - 可以存储**数组、字符串**，返回值是一个**对象**。
  > - 还可以用于去重

  ```js
  let arr1=[1,2,3,4,4,5,1];
  // {1, 2, 3, 4, 5}  1,2,3,4,5  []
  
  // 去重
  let arr2=[...new Set(arr1)];
  console.log(arr2);
  // [1, 2, 3, 4, 5]
  ```

  

- **map**

  - > 类似于对象，存放**键值对**，键和值可以是任何数据类型。



---



### js的作用域和作用域链

- **作用域：**变量起作用的范围，目的是为了隔离变量，保证不同作用域下的同名变量不会冲突；
  - 全局作用域
  - 函数作用域
  - 块作用域

 

---

### 匿名函数（自执行函数）

> 匿名函数也叫一次性函数，没用名字，且在定义时执行，且执行一次，不存在预解析（函数内部执行的时候会发生）。

- **匿名函数的作用**
  
  1. 对项目的初始化，页面加载时调用，保证页面有效的写入Js，不会造成全局变量污染 
  2. 防止外部命名空间污染 
  3. 隐藏内部代码暴露接口
  
- **匿名函数基本格式**

  ```js
  (function(){
    ...
  }());
  ```




---



---



### 构造函数

> 构造函数通过**new**关键字进行**调用**,构造函数的名字写成大驼峰

```js
// 创建一个类（函数）
function Person(name,age){
   this.name = name;
   this.age = age;
   this.eat = function(){
      console.log('我爱吃');
   }
}
// 普通函数调用
var result = Person('张三',18);
console.log(result);

// 构造函数调用            
var p1 = new Person('李四',16);
console.log(p1);

var c2 = new Person('王五',14);
console.log(p2);
```



---



### JS对数据类型的检测方式有哪些（常见）

[常用的数据类型检测方法](https://juejin.cn/post/6844904115097567239)

- typeof [value]
- [xxx] instanceof [类型]
- xxx.constructor === [类型]
- Object.prototype.toString.call(被检测的实例)



### 说一下闭包，闭包有什么特点

- **闭包就是内部函数可以访问外部作用域的变量，并返回内部函数**

- **闭包的原理：**因为作用域链而产生了闭包，由于内部函数是通过外部函数而创建的，所以两个函数具有相同的作用域链，这就导致了当外部函数调用完成并销毁后，由于内部函数被return出去了，所以内部函数还没有被销毁，从而可以访问外部函数的变量；

- **为什么要使用闭包：**因为**全局变量**会污染环境（因为所有的对象都可以访问同一个全局变量），而局部变量又无法长期驻留内存（因为函数调用完成后就会被自动销毁）

- [什么是闭包？](https://juejin.cn/post/6844903990656761864)

  - **闭包的四个条件**

     > 1、有函数嵌套
     >
     > 2、内部函数引用外部函数作用域中的变量参数
     >
     > 3、返回值是内部的函数
     >
     > 4、 要创建一个对象函数，让其长期驻留（因为函数在调用完成后就会被自动销毁）
     >
     > `var fm = fa() // 创建一个对象，使得闭包可以长期存在`

  - 闭包使用完成后可以**销毁**

    - `fm  = null`
    
    ``` js
    function fa() {
      let a = 10;
      return function(){
         a--;
         console.log(a);
      }
    }
    // 创建一个对象，使得闭包可以长期存在
    var fn = fa();
    ```



---



### 前端的内存泄漏怎么理解？

- **垃圾回收机制：**js自动释放不在使用的内存

- JS在使用时已经为对象分配了内存地址，但是由于长时间的没用释放内存或者没用清理内粗（例如，有很多闭包占用内存），造成了对象长期的占用内存的现象，这就会让内存越用越少，从而导致主机允许速度变慢，甚至崩溃；

---



### 7、事件委托（事件代理）是什么？

**原理：**利用事件冒泡的机制，将子元素的事件绑定到父元素的身上

**阻止事件冒泡：**event.stopPropagation()

**优点：**提高性能，减少了事件绑定的次数，也就减少了内存的占用



### 8、基本数据类型和引用数据类型的区别

**区别：****基本数据**类型保存在**栈内存**中（保存具体数据），**引用数据**类型保存在**堆内存中（保存地址）



### [说一下原型、原型链](https://juejin.cn/post/7007416743215759373)

- **为什么要有原型：**

  > 当我们需要同时**创建很多个相同对象**的时候，如果每次都要单独的实例化，则会占用很多内存。所以就要将这个函数保存到原型上供所有的对象访问；

- ______proto__可以理解为

---



### new操作符具体做了什么

- 先创建一个空对象
- 把空对象和构造函数通过原型链进行链接
- 把构造函数的**this**绑定到新的空对象身上
- 根据构造函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要**返回这个引用类型**

 

---



### 对象的深拷贝和浅拷贝

>  注：个人觉得**深拷贝和浅拷贝**是对**引用数据类型**对象来说的，如果是基本数据类型感觉就像简单的赋值一样

- **浅拷贝：**（拷贝的对象会影响被拷贝的对象）

  - > 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是**基本类型**，拷贝的就是基本类型的值，如果属性是**引用类型**，**拷贝的就是内存地址** ，所以***如果其中一个对象改变了这个地址，就会影响到另一个对象。***

  - ***实现浅拷贝的方法：***

    - **Object.assign() **————可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。

      ```js
      let obj1 = { person: {name: "kobe", age: 41},sports:'basketball' };
      let obj2 = Object.assign({}, obj1);
      obj2.person.name = "wade";
      obj2.sports = 'football'
      console.log(obj1); // { person: { name: 'wade', age: 41 }, sports: 'basketball' }
      ```

    - **函数库lodash的 _.clone方法：**

      ```js
      var _ = require('lodash');
      var obj1 = {
          a: 1,
          b: { f: { g: 1 } },
          c: [1, 2, 3]
      };
      var obj2 = _.clone(obj1);
      console.log(obj1.b.f === obj2.b.f);// true
      ```

    - **展开运算符...  ：**

      ```js
      let obj1 = { name: 'Kobe', address:{x:100,y:100}}
      let obj2= {... obj1}
      obj1.address.x = 200;
      obj1.name = 'wade'
      console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
      ```

- **深拷贝：**

  - > 深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且**修改新对象不会影响原对象**。

  - ***实现深拷贝的方法：***

    - **JSON.parse(JSON.stringify(  ))**

      - > 利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且**对象会开辟新的栈，实现深拷贝**。

      ```js
      let arr = [1, 3, {
          username: ' kobe'
      }];
      let arr4 = JSON.parse(JSON.stringify(arr));
      arr4[2].username = 'duncan'; 
      console.log(arr, arr4)
      ```

    - **函数库lodash的 _.cloneDeep方法**

      ```js
      var _ = require('lodash');
      var obj1 = {
          a: 1,
          b: { f: { g: 1 } },
          c: [1, 2, 3]
      };
      var obj2 = _.cloneDeep(obj1);
      console.log(obj1.b.f === obj2.b.f);// false
      ```



---

### 剩余运算符（其实就是拓展运算符的一种使用方式）

```js
  // 形参较多，放在最后位置
  function f3(a, b, ...args) {
      console.log(a,b);//1,2
      console.log(args);// [3,4,5]
      //
  }
  f3(1, 2, 3, 4, 5)
```



---

### 类的使用(ES6语法糖)

> 类（class）是ES6中语法糖，最终还是转化成**构造函数**去执行，使用class创建的类会将__方法__自动加到原型上

```js
 class Person{
    // 通过构造函数 -- 初始化实例化对象属性
    constructor(name,age){
      this.name=name;
      this.age= age;
    }
    // 添加方法 不需要添加,
    eat(){
      console.log('哈哈')
    }
  }
  const per = new Person('小明',20);
  console.log(per.name);
  per.eat();
```



---

### 改变this指向的方法：apply、call、bind

- 三者用法功能类似，只是写法有区别
- apply、call、bind是一个方法，**函数的方法**——说明只要是个函数就能调用这个方法来改变this指向

> **总结：**
>
> function.**call**( paramas1，number1,.........)
>
> - 第一个参数表明this指向谁（paramas1）
> - 第二个参数的向函数中传递的参数，**可以是任何类型的数据，例如数组，对象，函数**



- apply----->function.**apply**( [paramas1，[number1,.........]) `传参是通过数组传递的`
- bind----->let fun = function.**bind**( paramas1，number1,.........)    `call和apply会自己调用函数，而bind需要手动调用函数`

- 例子1：

  - ```js
    function fun(){
        console.log(this)
        console.log(this.name)
    }
    
    let cat = {
        name:'喵喵'
    }
    
    fun()	// 这时候this指向的是window对象
    fun.call(cat)	// 这里把本该指向window的this指向了cat
    ```

- 例子2：

  - ```js
    let dog = {
        name:'旺财',
        sayName(){
            console.log('我是'+ this.name)
        }，
        eat(food){
            console.log('我喜欢吃'+ food)
        }
    }
    
    let cat = {
        name:'喵喵'
    }
    
    dog.sayName()	// 根据就近原则，这里输出了旺财	
    dog.sayName.call(cat)	//sayName是一个函数，所以可以使用call来改变this指向
    
    dog.eat("骨头")	// 我喜欢吃骨头
    dog.eat.call(cat,"鱼")	// 我喜欢吃鱼
    ```

  - 

---



### 防抖与节流（手写）

[闭包手写](https://www.bilibili.com/video/BV1gV4y1a7L8/?spm_id_from=333.337.search-card.all.click&vd_source=0de1ee80a2ec8e9ede67cbdfd17acc85)

- > **防抖和节流能有效减少浏览器引擎的损耗，防止出现页面堵塞卡顿现象，需要熟练掌握。** 

- **防抖（debounce）：**就如同回城一样，前面所有的触发的回调都被取消，只有最后一次在经过设定的时间之后再触发回调（所以只会执行一次）
  
  - **应用场景：**
    
    > - 比较典型的是**搜索事件**，用户在不停的输入，就需要用防抖来节约请求资源，只有最后一次才触发请求操作；
    > - **按钮点击事件：**为了防止用户重复提交
  
- **节流（throttle）：**在**规定的时间**内**不会重复的触发**回调，只有大于这个时间间隔后才会重新触发回调（将频繁的触发改为少量触发）
  
  - **应用场景**
    - > - 自动保存功能，在规定的时间内去执行保存操作
      > - 监听滚动，

```js
// 防抖（用闭包实现）
// fn -- 需要执行的回调函数
// delay -- 延时器的时间
function debounce(fn, delay) {
    let timer = null;
    
    return function () {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
            //注意 我们使用apply进行一个换绑,绑到执行这个的DOM元素上
            fn.call(this);
        }, delay)
    }
}


// 节流（闭包实现）—————— 一段时间执行一次
function throttle(fn, delay) {	
    let t = true;			// 每次触发这个节流函数都会时t为true，这样才能执行定时器
    return function(){
        if(t){					// 当t为真的时候执行定时器
      		 setTimeOut(()=>{
        		 fn.call(this);
        		 t = true
      		 },delay)
    	}
   		 t = false        // 定时器执行完成后t为false，这样就不会再次执行定时器了
    }			
}
```



> 3. 
>4. 把node的事件循环也说一下，重复1、2、3点，node中的第3点要说的是node11前后的事件循环变动点。







### Promise

[promise讲解](https://www.bilibili.com/video/BV1TG411L7KM/?spm_id_from=333.337.search-card.all.click&vd_source=0de1ee80a2ec8e9ede67cbdfd17acc85)

- > Es6中**异步编程**新解决方案，主要解决异步**回调地狱**的问题（回调地狱：就是再函数嵌套调用的时候函数很乱的问题）

  ![image-20231128103811464](https://cdn.jsdelivr.net/gh/xiaobo1012/imgPicGo/imgs/202311281038670.png)

- Promise具有三个状态：**状态一旦改变就不会再发生变化了**

  - 初始状态 ： pending
  - 操作成功 ： resolved
  - 操作失败 ： rejected

- 实例方法

- **状态改变操作**

  - 状态的改变是通过 resolve() 和 reject() 函数来实现的

  - 异步操作成功调用**resolve**，会触发**than**回调函数，可以传参。

  - 异步操作失败调用**reject**，会触发**catch**回调函数，可以传参

  - ```js
    const p1 = new Promise{
     	if(a>1){
           resolve(100)
       }else{
           reject("失败")
       }
    }
     
    p1.then(data=>{
      console.log('data',data) // data 100
    }).catch(err=>{
      console.log('err',err) // err 失败
    })
     
    ```

- **Promise.all ( [ promise1 , promise2 , promise3 ]) **

  - > 批量一次性发送多个异步请求 返回值也是promise 如果数组中的promise都是成功的，那么返回的这个promise就是成功的，成功的结果就是所有的promise的成功结果组成的数组；

    ```js
    let p1 = new Promise((resolve)=>{
      setTimeout(()=>{
        console.log(1)
        resolve('1成功')
      },1000)
    })
    
    let p2 = new Promise((resolve)=>{
      setTimeout(()=>{
        console.log(2)
        resolve('2成功')
      },2000)
    })
    
    let p3 = new Promise((resolve)=>{
      setTimeout(()=>{
        console.log(3)
        resolve('3成功')
      },3000)
    })
    
    Promise.all([p1,p2,p3]).then(res=>{
      console.log(res)
    })
    
    // 1 2 3
    //['1成功', '2成功', '3成功']
    ```



### asyn 和 await

> 用同步的方式去执行异步的操作





### 宏任务和微任务

- 宏任务和微任务都是异步任务，微任务的优先级更高**（微任务 > DOM渲染 > 宏任务）**

> js是一个单线程的脚本语言，所以所有的任务都得一个一个来执行，只能排队了；

> - **宏任务** ----  script（整体代码）、setTimeout、setInterval、DOM事件、AJAX请求
>   - `script（整体代码） 这里的意思是整个script代码块都是一个宏任务，`
> - **微任务 **---- promise、async/await   **（微任务 > DOM渲染 > 宏任务）**

**同步任务和异步任务的执行顺序：**

> 1. 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数
> 2. 当指定的事情完成时，Event Table会将这个函数移入Event Queue。
> 3. 主线程内的任务执行完毕，主线程执行栈为空时，会去Event Queue读取对应的函数，进入主线程执行。
> 4. 上述过程会不断重复，也就是常说的Event Loop(事件循环)。





### [事件循环原理](https://juejin.cn/post/6844904079353708557?searchId=202311291720179752A2342D02A100C876)

[视频教程](https://www.bilibili.com/video/BV1Qe4y1K7r3/?spm_id_from=333.337.search-card.all.click&vd_source=0de1ee80a2ec8e9ede67cbdfd17acc85)

> 答题思路：
>
> 1. 先说**基本知识点**，**宏任务、微任务有哪些**
> 2. 说**事件循环机制过程**，边说边画图出来
> 3. 说async/await执行顺序注意，可以把 chrome 的优化，做法其实是违法了规范的，V8 团队的PR这些自信点说出来，显得你很好学，理解得很详细，很透彻。





# VUE

[vue2023前端面试题](https://juejin.cn/post/7191325434486161467)

### MVVM模型

- MVVM，是`Model-View-ViewModel`的简写

- `Model` 代表**数据模型**
- `View` 代表看到的**页面**
- `ViewModel`是`View`和`Model`之间的桥梁，
  - 数据会绑定到`ViewModel`层并自动将数据渲染到页面中
  - 视图变化的时候会通知`ViewModel`层更新数据。
- 以前是通过操作`DOM`来更新视图，现在是`数据驱动视图`。





### Vue 的性能优化方法？

- 路由懒加载。有效拆分应用大小，访问时才异步加载。
- `keep-alive`缓存页面。避免重复创建组件实例，且能保留缓存组件状态。
- `v-for`遍历避免同时使用`v-if`。实际上在 Vue 3 中已经是一个错误用法了。
- 长列表性能优化，可采用虚拟列表。
- `v-once`。不再变化的数据使用`v-once`。
- 事件销毁。组件销毁后把全局变量和定时器销毁。
- 图片懒加载。
- 第三方插件按需引入。
- 子组件分割。较重的状态组件适合拆分。
- 服务端渲染。





###虚拟dom是什么? 原理? 优缺点?

> **总结**：JS去按照DOM结构来实现的树形结构对象，你也可以叫做**DOM对象**

> **虚拟DOM：解决浏览器性能问题而被设计出来的**
>
> - 当DOM树更新时不会立即去操作DOM，而是将更新的diff保存到一个js对象中，然后在渲染时和真实DOM进行比较，不同处才进行更新DOM树

> **虚拟DOM的好处：**
>  (1) 性能提升
>  直接操作DOM是有限制的，一个真实元素上有很多属性，如果直接对其进行操作，同时会对很多额外的属性内容进行了操作，这是没有必要的。如果将这些操作转移到JS对象上，就会简单很多。另外，操作DOM的代价是比较昂贵的，频繁的操作DOM容易引起页面的重绘和回流。如果通过抽象VNode进行中间处理，可以有效减少直接操作DOM次数，从而减少页面的重绘和回流。
>  (2) 方便跨平台实现
>  同一VNode节点可以渲染成不同平台上对应的内容，比如：渲染在浏览器是DOM元素节点，渲染在Native（iOS、Android）变为对应的控件。Vue 3 中允许开发者基于VNode实现自定义渲染器（renderer），以便于针对不同平台进行渲染



### diff 算法

1. 概念：
    `diff`算法是一种对比算法，通过对比新旧虚拟DOM，找出不同的地方进行修改
2. 对比方式：
    `diff`算法的整体策略是：`深度优先，同层比较`。比较只会在同层级进行, 不会跨层级比较；比较的过程中，循环从两边向中间收拢。

相同时，先替换属性，然后对比子元素，分为以下几种情况：

- > - 新旧节点都有子元素时，采用双指针方式进行对比。新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用`createElem`创建一个新节点，从哈希表寻找 `key`一致的`VNode`节点再分情况操作。
  > - 新节点有子元素，旧节点没有子元素，则将子元素虚拟节点转化成真实节点插入即可。
  > - 新节点没有子元素，旧节点有子元素，则清空子元素，并设置为新节点的文本内容。
  > - 新旧节点都没有子元素时，则对比节点内容是否一致



### Vue中key的作用？

`key`的作用主要是`为了更加高效的更新虚拟 DOM`。

Vue 判断两个节点是否相同时，主要是判断两者的`key`和`元素类型tag`。因此，如果不设置`key` ，它的值就是 undefined，则可能永远认为这是两个相同的节点，只能去做更新操作，将造成大量的 DOM 更新操作。





### vue双向绑定原理

1. **原理：**
    Vue2.x 采用**数据劫持结合发布订阅模式**（PubSub 模式）的方式，通过 Object.defineProperty 来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。



### v-model双向绑定原理

1. **概念：**

   `v-model`是语法糖，默认情况下相当于`:value`和`@input`，使用`v-model`可以减少大量繁琐的事件处理代码，提高开发效率。

2. **使用：**
   通常在表单项上使用`v-model`，还可以在自定义组件上使用，表示某个值的输入和输出控制。



### Vue.$nextTick

- **在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。**

- `nextTick` 是 Vue 提供的一个全局 API，由于 Vue 的**异步更新策略**，导致我们对数据修改后不会直接体现在 DOM 上，此时如果想要立即获取更新后的 DOM 状态，就需要借助该方法。

Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue 将开启一个异步更新队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 `watcher` 被多次触发，只会被推入队列一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。`nextTick`方法会在队列中加入一个回调函数，确保该函数在前面的 DOM 操作完成后才调用。

使用场景：

1. 如果想要在修改数据后立刻得到更新后的`DOM`结构，可以使用`Vue.nextTick()`
2. 在`created`生命周期中进行`DOM`操作



### Vue 的响应式原理

1. Vue 2 中的数据响应式会根据数据类型做不同的处理。如果是对象，则通过

   ```
   Object.defineProperty(obj,key,descriptor)
   ```

   拦截对象属性访问，当数据被访问或改变时，感知并作出反应；如果是数组，则通过覆盖数组原型的方法，扩展它的7个变更方法（push、pop、shift、unshift、splice、sort、reverse），使这些方法可以额外的做更新通知，从而做出响应。

   缺点：

   - 初始化时的递归遍历会造成性能损失；
   - 通知更新过程需要维护大量 `dep` 实例和 `watcher` 实例，额外占用内存较多；
   - 新增或删除对象属性无法拦截，需要通过 `Vue.set` 及 `delete` 这样的 API 才能生效；
   - 对于`ES6`中新产生的`Map`、`Set`这些数据结构不支持。

2. Vue 3 中利用`ES6`的`Proxy`机制代理需要响应化的数据。可以同时支持对象和数组，动态属性增、删都可以拦截，新增数据结构均支持，对象嵌套属性运行时递归，用到时才代理，也不需要维护特别多的依赖关系，性能取得很大进步。



### 为什么组件中的 data 是一个函数？

在 new Vue() 中，可以是函数也可以是对象，因为根实例只有一个，不会产生数据污染。

> 在组件中，data 必须为函数，目的是为了**防止多个组件实例对象之间共用一个 data，产生数据污染**；
>
> 而采用函数的形式，initData 时会将其作为**工厂函数**都会返回全新的 data 对象。



### Vue 中组件间的通信方式？

#### 父组件——>子组件【props】

> 父向子传递数据是通过`props`，这个传递是单向的，避免了子组件修改父组件的值

```js
// 再父组件中调用子组件时传递数据
<child :xxxx='aaaa'></child>		// xxxx——>props使用名称		aaaa——>传递的内容

// 子组件获取传递的数据
export default {
  props: ['xxxx']
}

1.这样就可以再子组件中使用父组件传递的数据了
[总结:] prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。
而且 prop 只读，不可被修改，所有修改都会失效并警告。
```



#### 子组件——>父组件【$emit】【ref】

```js
// 再父组件中调用子组件时定义一个自定义事件
<child @xxx="aaaa"></child>		// xxx——>事件名称	aaaa——>回调函数

// 在子组件中触发自定义事件
triggerEvent(){
    this.$emit("xxx"，bbbb)			//this指向vc实例	 bbbb——>表示可以传递参数，也可以不传
}

// 父组件中的回调函数就可以获取到子组件中传递过来的数据了
```

```js
// 通过ref获取到子组件，从而获取到子组件中的data与method
<child ref='child'></child>	

// 在父组件中获取到子组件对象
this.$refs.child
```





#### 全局事件总线

1. 注册全局事件总线，将其放到原型上

<img src="https://cdn.jsdelivr.net/gh/xiaobo1012/imgPicGo/imgs/202312181530906.png" alt="img" style="zoom:50%;" /> 

2. 使用`$on`去设置一个全局事件总线【在需要接收数据的组件中】

```js
this.$bus.$on("事件总线的名称"，回调函数)		// 这个回调函数可以接收传递过来的参数
```

3. 在传递数据的组件中使用`$emit`触发事件总线

```js
this.$bus.$on("事件总线的名称"，传递的参数)		//事件总线的名称必须是之前设置好的
```

4. 销毁事件——否则这个事件名称会被一直占用

```js
beforeDestroy{
    // 在生命周期钩子中进行销毁
    // 在哪里定义的事件总线就在哪里销毁	on与off必须成对出现
    this.$bus.$off("事件总线的名称")		
}
```



#### **消息的订阅与发布**

> 需要数据的组件【订阅消息】	发送数据的组件【发布消息】
>
> 每个消息都有一个id
>
> 需要用这个id来销毁事件

1. 安装消息订阅库

```js
npm install pubsub
```

2. 在需要【接收、发布】数据的组件中引入 消息库

```js
import pubsub from 'pubsub-js'
```

3. 【订阅消息】

```js
// 用this.xxx来保存这个消息的id
this.xxx = pubsub.subscribe("消息的名称"，（msgName,data）=>{
           		 // 第一个参数是消息的名称【必须写，但是可以不用】
                 // 第二个参数才是传递回来的数据
           })
```

4. 【发布消息】

```js
pubsub.publish("消息的名称"，传递的数据)
```

5. 销毁事件

```js
beforeDestory(){
    pubsub.unsubscribe(this.xxx)
}
```











### Vue 2中的set方法？

[`set`是Vue 2中的一个全局API](https://link.juejin.cn?target=https%3A%2F%2Fv2.cn.vuejs.org%2Fv2%2Fapi%2F%23Vue-set)。可手动添加响应式数据，解决数据变化视图未更新问题。

当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，会发现页面并没有更新。

这是因为`Object.defineProperty()`的限制，监听不到数据变化，

**可通过`this.$set(数组或对象，数组下标或对象的属性名，更新后的值)`解决。**





### 插槽

> `slot`插槽，一般在组件内部使用，封装组件时，在组件内部**不确定该位置是以何种形式的元素展示**时，可以通过`slot`占据这个位置，该位置的元素需要**父组件以内容形式传递**过来。

`slot`分为：

- **默认插槽：**子组件用`<slot>`标签来确定渲染的位置，标签里面可以放`DOM`结构作为后备内容，当父组件在使用的时候，可以直接在子组件的标签内写入内容，该部分内容将插入子组件的`<slot>`标签位置。如果父组件使用的时候没有往插槽传入内容，后备内容就会显示在页面。

- **具名插槽：**子组件用`name`属性来表示插槽的名字，没有指定`name`的插槽，会有隐含的名称叫做 `default`。父组件中在使用时在默认插槽的基础上通过`v-slot`指令指定元素需要放在哪个插槽中，`v-slot`值为子组件插槽`name`属性值。使用`v-slot`指令指定元素放在哪个插槽中，必须配合`<template>`元素，且一个`<template>`元素只能对应一个预留的插槽，即不能多个`<template>` 元素都使用`v-slot`指令指定相同的插槽。`v-slot`的简写是`#`，例如`v-slot:header`可以简写为`#header`。

- **作用域插槽：**可以实现子组件将数据传递给父组件

  > 1. 可以将子组件中的数据传给slot的使用者，这样就可以再父组件中使用传递过来的数据了
  >
  > 2. 使用<slot>标签上的属性 将子组件的数据传给slot的使用者
  >
  >    <img src="https://cdn.jsdelivr.net/gh/xiaobo1012/imgPicGo/imgs/202311231629894.png" alt="img" style="zoom: 67%;" /> 
  >
  >    3. 使用者去接收对象
  >    
  >    <img src="https://cdn.jsdelivr.net/gh/xiaobo1012/imgPicGo/imgs/202311231631276.png" alt="img" style="zoom:67%;" /> 
  >    
  >    3. xxx中保存的是一个对象，这个对象里面保存了从slot中传过来的数据（可以采用解构赋值的方式拿到aaa）
  >    
  >       <img src="https://cdn.jsdelivr.net/gh/xiaobo1012/imgPicGo/imgs/202311231631937.png" alt="img" style="zoom:67%;" /> 
  
  数据，以将子组件数据传给父组件使用。父组件获取插槽绑定 props 数据的方法：
  
  1. scope="接收的变量名"：`<template scope="接收的变量名">`
  2. slot-scope="接收的变量名"：`<template slot-scope="接收的变量名">`
  3. v-slot:插槽名="接收的变量名"：`<template v-slot:插槽名="接收的变量名">`





### Vue 中的修饰符有哪些？

在Vue 中，修饰符处理了许多 DOM 事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。Vue中修饰符分为以下几种：

1. **表单修饰符**
    `lazy` 填完信息，光标离开标签的时候，才会将值赋予给value，也就是在`change`事件之后再进行信息同步。
    `number` 自动将用户输入值转化为数值类型，但如果这个值无法被`parseFloat`解析，则会返回原来的值。
    `trim` 自动过滤用户输入的首尾空格，而中间的空格不会被过滤。

2. **事件修饰符**
    `stop` 阻止了事件冒泡，相当于调用了`event.stopPropagation`方法。
    `prevent` 阻止了事件的默认行为，相当于调用了`event.preventDefault`方法。
    `self` 只当在 `event.target` 是当前元素自身时触发处理函数。
    `once` 绑定了事件以后只能触发一次，第二次就不会触发。
    `capture` 使用事件捕获模式，即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理。
    `passive` 告诉浏览器你不想阻止事件的默认行为。
    `native` 让组件变成像`html`内置标签那样监听根元素的原生事件，否则组件上使用 `v-on` 只会监听自定义事件。

3. **鼠标按键修饰符**
    `left` 左键点击。
    `right` 右键点击。
    `middle` 中键点击。

4. **键值修饰符**

   键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：keyCode存在很多，但vue为我们提供了别名，分为以下两种：

   - 普通键（enter、tab、delete、space、esc、up...）
   - 系统修饰键（ctrl、alt、meta、shift...）



### 路由

#### **解释 hash 模式和 history 模式的实现原理**

> - hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。
>
> - history 模式的实现，主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以在改变 URL，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作

> 两种模式的区别：
>
> - 首先是在 URL 的展示上，hash 模式有“#”，history 模式没有
> - 刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由
> - 在兼容性上，hash 可以支持低版本浏览器和 IE。



#### router 和 route 的区别？

1. `$route`是一个跳转的路由对象，可以认为是当前组件的路由管理，指当前激活的路由对象，包含当前url解析得到的数据，可以从对象里获取一些数据，如：name，path，params，query等。
2. `$router` 对象是全局路由的实例，是 router 构造方法的实例。
   1. $router 对象常用的方法有：
      - push：向 history 栈添加一个新的记录
      - go：页面路由跳转前进或者后退
      - replace：替换当前的页面，不会向 history 栈添加一个新的记录






#### vue-router 的路由传参方式？

- **声明式导航** `router-link`：

  - ``` vue
    <router-link :to="'/users?userId:1'"></router-link>
    <router-link :to="{ name: 'users', params: { userId: 1 } }"></router-link>
    <router-link :to="{ path: '/users', query: { userId: 1 } }"></router-link>
    ```

- **编程式导航** `router-push`

  - 通过`paramas`传递参数

    - ```js
      this.$router.push({
        name: 'users',
        params: {
            userId: 1
        }
      });
      // 路由配置
      // 这里需要进行占位
      {
        path: '/users:userId',
        name: 'users',
        component: User
      }
      // 跳转后获取路由参数
      this.$route.params.userId // 为 1
      ```

  - 通过`query`传参
  
    - ```js
      this.$router.push({
          path: '/users',
          query: {
              userId: 1
          } 
      });
      // 路由配置
      {
          path: '/users',
          name: 'users',
          component: User
      }
      // 跳转后获取路由参数
      this.$route.query.userId
      ```







### Vuex

1. **概念：**
   Vuex 是 Vue 专用的**状态管理仓库**，采用集中式存储管理应用的所有组件的状态。

2. **为什么需要 vuex**

   由于组件只维护自身的状态(data)，组件创建时或者路由切换时，组件会被初始化，从而导致 data 也随之销毁。

3. **解决的问题：**
   Vuex 主要解决的问题是**多组件之间状态共享**。Vuex 通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向流动，使代码变得更具结构化且易于维护。

4. **用法：**
   Vuex 将全局状态放入`state`对象中，它本身是一颗状态树，组件中使用`store`实例的`state`访问这些状态；然后用配套的`mutation`方法修改这些状态，并且只能用`mutation`修改状态，在组件中调用`commit`方法提交`mutation`；如果应用中有异步操作或复杂逻辑组合，需要编写`action`，执行结束如果有状态修改仍需提交`mutation`，组件中通过`dispatch`派发`action`。最后是模块化，通过`modules`选项组织拆分出去的各个子模块，在访问状态（state）时需注意添加子模块的名称，如果子模块有设置`namespace`，那么提交`mutation`和派发`action`时还需要额外的命名空间前缀。



### 生命周期

[图解](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/21/164bbf610b61f3cd~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

####**什么是 vue 生命周期**

> 对于 vue 来讲，生命周期就是一个 vue 实例从创建到销毁的过程。

####**vue 生命周期的作用是什么**

> 最主要的其实是**生命周期函数**，**给予了开发者在不同的生命周期阶段添加业务代码的能力。**

#### **vue 生命周期有几个阶段**

> 它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。
>
> 1. **beforeCreate**：是 new Vue( ) 之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都**不能被访问**。
> 2. **created**：在实例创建完成后发生，当前阶段**可以使用数据，更改数据**，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 DOM 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 DOM 。
> 3. **beforeMount**：发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段**虚拟 DOM** 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。
> 4. **mounted**：在挂载完成后发生，在当前阶段，**真实的 DOM **挂载完毕，数据完成双向绑定，可以访问到 DOM 节点，使用 $refs 属性对 DOM 进行操作。
> 5. **beforeUpdate**：发生在更新之前，也就是响应式数据发生更新，**虚拟 DOM 重新渲染之前**被触发，你可以在当前阶段进行更改数据，不会造成重渲染。
> 6. **updated**：发生在更新完成之后，当前阶段组件 DOM 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
> 7. **beforeDestroy**：发生在**实例销毁之前**，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器，清除全局事件总线。
> 8. **destroyed**：发生在实例销毁之后，这个时候只剩下了 DOM 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

####**第一次页面加载会触发哪几个钩子**

> 会触发 4 个钩子，分别是：beforeCreate、created、beforeMount、mounted
>
> 创建 + 挂载

#### **DOM 渲染在哪个周期就已经完成**

> DOM 渲染是在 mounted 阶段完成，此阶段真实的 DOM 挂载完毕，数据完成双向绑定，可以访问到 DOM 节点。

####**多组件（父子组件）中生命周期的调用顺序说一下**

> 组件的调用顺序都是先父后子，渲染完成的顺序是先子后父。
>
> 组件的销毁操作是先父后子，销毁完成的顺序是先子后父。
>
> 1. 加载渲染过程：父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted
> 2. 子组件更新过程：父beforeUpdate->子beforeUpdate->子updated->父updated
> 3. 销毁过程：父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
>
>  
>
> 父beforeMount这个阶段，模板以及被加载，虚拟DOM被创建，所以子组件也会开始被创建了

















# Git

#### git常用命令

> **1、设置用户签名**：`git config --global user.name [用户名]`
>
> **2、设置用户邮箱签名：**`git config --global user.email 邮箱`
>
> - - > global表示全局配置，只需要再电脑上配置一次
>     >
>     > git config --global --list 可查看配置好的全局配置
>
> **3、初始化仓库：**`git init`
>
> **4、添加暂存区：**`git add [文件名] / .   `       .。 表示提交当前文件夹下所有的文件
>
> - 删除暂存区中某个文件：`git rm --cached [文件名]`
> - 清空暂存区：``git reset``
>
> **5、提交到本地库：** `git commit  -m "这里写简介"  [文件名]`
>
> **6、设置远程仓库：**`git remote add [仓库别名] [仓库地址]`   ---- **一个文件只用设置一次**
>
> - > **git remote -v **  可以查看有几个远程仓库
>   >
>   > **git remote  rename [old_name] [new_name]**   可修改别名
>   >
>   > **git remote romove [别名]**   删除仓库
>
> 
>
> **7、将代码提交到远程仓库：**`git push  [仓库别名] 【master/其他仓库分支】`
>
> **8、拉取远程仓库到本地：**`git pull [仓库别名] 【master/其他仓库分支】`---------*养成提交后才拉取一次的习惯*



- **查看用户签名和邮箱**：`cat ~/.gitconfig`

- **查看本地库状态：**`git status`

- **克隆远程仓库：**`git clone 【仓库地址】`

  - > 克隆下来的仓库，默认别名就是**origin**



***注：解决git SSL certificate problem: unable to get local issuer certificate保存的问题***

> 这个问题是由于没有配置信任的服务器HTTPS验证。默认，[cURL](https://so.csdn.net/so/search?q=cURL&spm=1001.2101.3001.7020)被设为不信任任何CAs，就是说，它不信任任何服务器验证。
>
> git config --global http.sslVerify false



#### git分支操作

https://www.bilibili.com/video/BV1ai4y1M7FN?p=5&spm_id_from=pageDriver&vd_source=0de1ee80a2ec8e9ede67cbdfd17acc85

> 当多个人对同一个项目进行编写的时候，为了将自己的任务和主线程分开，就需要采用的到分支操作
>
> 再组员进行编写代码的时候只能使用其他分支进行提交
>
> master分支只有组长在合并代码的时候使用

- **查看分支：**`git branch -v`

- **创建分支：**`git branch [分支名称]`

- **删除分支：**

  - > ```git
    > // 删除本地分支
    > git branch -d localBranchName
    > 
    > // 删除远程分支
    > git push origin --delete remoteBranchName
    > ```

- **切换分支：**`git checkout [分支名称]`

  - > 这样就可以随意的去修改文件中的数据了，因为我们可以随时去删除这个分支（只要在分支与主线合并之前）
    >
    > **git checkout -b 【分支名称】**------- 创建分支并且切换分支
    >
    > 当切换分支的时候，文件中的代码也会随之切换【本地库保存了分支文件】

- **合并分支：**`git merge 【分支名称】`

  - > 1. 切换到分支上，并且git pull拉取最新分支代码，确认代码后再确认是否需要合并到master分支
    > 2. 切换到master分支
    > 3. 开始合并分支git merge







#### 【注】：冲突合并

> 当主线分支与创建的其他分支同时都被修改后，无法进行自动合并分支（需要手动修改）
>
> 文件中会标出两个分支发生冲突的地方（把不需要的代码手动删除就行了）
>
> 当手动删除代码后，还需要将代码重新上传本地库（这时候就不需要带上文件名称了）【只会修改master分支的文件】

![img](https://cdn.jsdelivr.net/gh/xiaobo1012/imgPicGo/imgs/202311221634041.png)



#### git远程仓库使用（团队协作）

- 设置远程仓库**【git remote （别名） （仓库地址）】**

- 推送本地库到远程库**【git push （别名）(本地库的哪个分支)】**

- 拉取远程库到本地库**[git pull (远程库别名)  （远程库分支）]**

- 克隆远程库到本地**【git clone （仓库地址）】**

  - 克隆的文件可以直接git push 和 git pull  ，不用输入仓库名和分支名

- ***团队开发多个分支时***

  - > 1. 当队员提交分支后，队长可以**直接切换**到对应分支，而不用去git pull拉取分支下来
    > 2. **在切换到分支后，再使用git pull 拉取分支的最新代码**




- **团队开发**

  - > 1、想要团队开发，则需要在远程库中将所以成员都添加进去（这样才能进行代码的push操作）
    >
    > 2、邀请后将邀请函（也就是一个链接地址），发送被邀请的人
    >
    > 3、被邀请的人打开连接，接受邀请
    >
    > 4、之后被邀请的人的代码就可推送到这个远程仓库了

- **SSH免密登录：**https://www.bilibili.com/video/BV1vy4y1s7k6/?p=26&spm_id_from=pageDriver&vd_source=66441f23d5d3bbb2f332e315c9c9f6f5

  - > 1. 在git BUSH中输入`ssh-keygen.exe`
    > 2. 在对应的电脑用户文件夹中找到 C盘—>当前账户—> ssh —> id_rsa.pub  将里面的代码全选复制后去github上保存下来




#### git merge 和 git rebase的区别

> **相同点**
>
> - 都是将任意一个分支合并到当前分支

> 不同点
>
> - git merge 在合并时会自动提交到本地库，如果合并时遇见冲突则需要修改后重新commit（这里需要自己手动 add 和 commit  【注】：在commit的时候不用带上文件名）
> - 





#### git版本控制

- **查看历史日志：**`git reflog   /   git log`

- **版本迭代：**当版本提交到本地库后被更改，需要重新再次上传本地库，这时就会出现两个版本的代码（使用进行版本穿梭了）
- **版本穿梭：**`git reset --hard  （版本号）`  ***注：版本号在查看日志的时候可以看到***





# webpack





# TypeScript













# 面试题汇总

- 

  





# 滴滴真实面试题

#### 1、闭包是什么？闭包的用途





#### 2、简述事件循环原理

- js事件循环是一种机制，用来**处理异步事件和回调函数**。
- 由于**js是单线程**的，所以所有的事件会被放入队列中，然后按照顺序依次执行。在js执行代码的时候，**同步任务会被立即执行，而异步任务则会被放入事件队列中**。
- 当所有同步任务执行完毕后，事件循环会从事件队列中取出一个任务，并将其放入调用栈中执行。当该任务执行完毕后，事件循环会再次从事件队列中取出下一个任务，并重复这个过程。



#### 4、

#### 5、vue 和 react 里的key的作用是什么? 为什么不能用Index？用了会怎样? 如果不加key会怎样?



#### 6、vue 双向绑定的原理是什么?

> vue是采用**数据劫持**结合**发布者-订阅者模式**的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发响应的监听回调。

[用自己的话总结vue双向绑定数据原理](https://juejin.cn/post/6844904015516401678)



#### 7、vue 的keep-alive的作用是什么？怎么实现的？如何刷新的?





#### 8、vue 是怎么解析template的? template会变成什么?





#### 9、如何解析指令? 模板变量? html标签



#### 10、用过vue 的render吗? render和template**有什么关系**





# 58面试真题

#### 1、对前端工程化的理解

#### 2、前端性能优化都做了哪些工作

#### 3、Nodejs 异步IO模型

#### 4、libuv

#### 5、设计模式

#### 6、微前端

#### 8、react有自己封装一些自定义hooks吗? vue有自己封装一些指令吗

#### 9、vue 向 react迁移是怎么做的? 怎么保证兼容的

#### 10、vue的双向绑定原理

通过v-model可以实现数据的双向绑定

```js
```





#### 11、Node的日志和负载均衡怎么做的

#### 12、那前后端的分工是怎样的？哪些后端做哪些node做



###二面

#### 1、了解过vue3吗?

#### 2、webscoket的连接原理

#### 3、vue生命周期

#### 4、redux原理

#### 5、vue 父子组件的通信方式

#### 6、async await的原理是什么?

#### 7、async/await, generator, promise这三者的关联和区别是什么?

#### 8、做过哪些性能优化?





# 金山面试真题

#### 1、react和vue在技术层面的区别

#### 2、常用的hook都有哪些?

#### 3、用hook都遇到过哪些坑?

#### 4、了解useReducer吗

#### 5、组件外侧let a 1 组件内侧点击事件更改a，渲染的a会发生改变吗？如果let a放在组件内部，有什么变化吗？和useState有什么区别？

#### 6、了解过vue3吗?

#### 7、Node是怎么部署的? pm2守护进程的原理?

#### 8、Node开启子进程的方法有哪些?

#### 9、进程间如何通信?

#### 10、css 三列等宽布局如何实现? flex 1是代表什么意思？分别有哪些属性?

#### 11、前端安全都了解哪些? xss csrf

- ##### csp是为了解决什么问题的?

- ##### https是如何安全通信的?

#### 12、前端性能优化做了哪些工作?



# 一些问题的汇总

















  
